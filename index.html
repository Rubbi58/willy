<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hóriver – Wall Tiles Test (100×100)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050104;
      color: #f7e3c8;
      overflow: hidden;
    }

    h1 {
      margin-top: 10px;
      text-align: center;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 18px;
      color: #ffdd88;
    }

    #subtitle {
      text-align: center;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-top: 4px;
      color: #ffbb66;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 90px);
    }

    canvas {
      border: 2px solid #ffcc66;
      background: #000;
      image-rendering: pixelated;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    #controls {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
      color: #ffe6bf;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>HÓRIVER – WALL TILE TEST</h1>
  <div id="subtitle">Check walls & floor from dungeons-pack.png</div>

  <div id="game-wrapper">
    <canvas id="game" width="800" height="800"></canvas>
    <div id="controls">
      Move with <b>W A S D</b>. Simple light, no cone. Just testing tiles.
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const WORLD_W = 100;
    const WORLD_H = 100;

    const T_WALL  = 1;
    const T_FLOOR = 0;

    // --- deterministic random for floor defects / bones ---
    function coordRand(x, y, seed = 1337) {
      let n = x * 374761393 + y * 668265263 + seed * 1442695040888963407;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }

    // --- world array ---
    const world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = [];
      for (let x = 0; x < WORLD_W; x++) {
        row.push(T_FLOOR);
      }
      world.push(row);
    }

    // helper: carve rectangle of walls (frame), interior floor
    function carveRoomFrame(x0, y0, x1, y1) {
      for (let y = y0; y <= y1; y++) {
        for (let x = x0; x <= x1; x++) {
          if (x === x0 || x === x1 || y === y0 || y === y1) {
            world[y][x] = T_WALL;
          } else {
            world[y][x] = T_FLOOR;
          }
        }
      }
    }

    // outer big frame (like outer walls)
    carveRoomFrame(2, 2, 97, 97);

    // central hall (4 tiles wide vertically)
    carveRoomFrame(48, 10, 51, 90);

    // left room
    carveRoomFrame(10, 20, 35, 45);

    // right room
    carveRoomFrame(65, 20, 90, 45);

    // bottom-left room
    carveRoomFrame(10, 60, 35, 85);

    // bottom-right room
    carveRoomFrame(65, 60, 90, 85);

    // simple 4-wide corridor from central hall to left/right rooms
    for (let y = 32; y <= 37; y++) {
      for (let x = 35; x <= 48; x++) {
        world[y][x] = T_FLOOR;
      }
      for (let x = 51; x <= 65; x++) {
        world[y][x] = T_FLOOR;
      }
    }

    function tileAt(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
      return world[ty][tx];
    }

    function isWalkable(tx, ty) {
      return tileAt(tx, ty) !== T_WALL;
    }

    // --- player ---
    let player = {
      x: (50 + 0.5) * TILE,
      y: (50 + 0.5) * TILE,
      vx: 0,
      vy: 0
    };

    const keys = { w: false, a: false, s: false, d: false };

    window.addEventListener("keydown", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
    });

    window.addEventListener("keyup", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    // --- assets (tileset only) ---
    function makeImage(name) {
      const img = new Image();
      img.src = "images/" + encodeURIComponent(name);
      return img;
    }

    const imgTiles = makeImage("dungeons-pack.png");

    function drawTilesetTile(img, tileX, tileY, dx, dy) {
      if (!img.complete || !img.naturalWidth) {
        ctx.fillStyle = "#444";
        ctx.fillRect(dx, dy, TILE, TILE);
        return;
      }
      const sx = (tileX - 1) * 32; // 32×32 tiles
      const sy = (tileY - 1) * 32;
      ctx.drawImage(img, sx, sy, 32, 32, dx, dy, TILE, TILE);
    }

    // your coordinates from dungeons-pack.png:
    // floor variants: (18,11), (19,11), (12,11), bones at (11,15)
    // walls:
    // top-left corner:  (13,6)
    // top-right corner: (14,6)
    // bottom-left:      (13,7)   // I assume 7 here; you wrote (13,6), but that’s likely a typo
    // bottom-right:     (14,7)
    // vertical wall:    (12,7)
    // end-wall cap:     (9,6)

    function drawFloor(tx, ty, dx, dy) {
      const r = coordRand(tx, ty);
      if (r < 0.33) drawTilesetTile(imgTiles, 18, 11, dx, dy);
      else if (r < 0.66) drawTilesetTile(imgTiles, 19, 11, dx, dy);
      else drawTilesetTile(imgTiles, 12, 11, dx, dy);

      // bones sprinkled
      if (r > 0.92) {
        drawTilesetTile(imgTiles, 11, 15, dx, dy);
      }
    }

    function drawWall(tx, ty, dx, dy) {
      const up    = tileAt(tx, ty - 1) === T_WALL;
      const down  = tileAt(tx, ty + 1) === T_WALL;
      const left  = tileAt(tx - 1, ty) === T_WALL;
      const right = tileAt(tx + 1, ty) === T_WALL;

      // corners
      if (!up && !left && right && down) {
        // top-left corner
        drawTilesetTile(imgTiles, 13, 6, dx, dy);
        return;
      }
      if (!up && !right && left && down) {
        // top-right corner
        drawTilesetTile(imgTiles, 14, 6, dx, dy);
        return;
      }
      if (!down && !left && right && up) {
        // bottom-left corner
        drawTilesetTile(imgTiles, 13, 7, dx, dy); // if you really want (13,6) here, change 7 to 6
        return;
      }
      if (!down && !right && left && up) {
        // bottom-right corner
        drawTilesetTile(imgTiles, 14, 7, dx, dy);
        return;
      }

      // vertical-only
      if (up && down && !left && !right) {
        drawTilesetTile(imgTiles, 12, 7, dx, dy);
        return;
      }

      // end cap (only one neighbor in any direction)
      const neighbors = (up?1:0)+(down?1:0)+(left?1:0)+(right?1:0);
      if (neighbors === 1) {
        drawTilesetTile(imgTiles, 9, 6, dx, dy);
        return;
      }

      // horizontal or mixed – just reuse top-edge pieces alternating
      if (left || right) {
        const useRightPiece = ((tx + ty) % 2 === 0);
        if (useRightPiece) drawTilesetTile(imgTiles, 14, 6, dx, dy);
        else drawTilesetTile(imgTiles, 13, 6, dx, dy);
        return;
      }

      // fallback
      drawTilesetTile(imgTiles, 13, 6, dx, dy);
    }

    function moveEntity(ent, dt) {
      const nextX = ent.x + ent.vx * dt;
      const nextY = ent.y + ent.vy * dt;

      const txNewX = Math.floor(nextX / TILE);
      const tyCur  = Math.floor(ent.y / TILE);
      if (isWalkable(txNewX, tyCur)) ent.x = nextX;

      const txCur  = Math.floor(ent.x / TILE);
      const tyNewY = Math.floor(nextY / TILE);
      if (isWalkable(txCur, tyNewY)) ent.y = nextY;
    }

    function update(dt) {
      const speed = 140;
      let dx = 0, dy = 0;
      if (keys.w) dy -= 1;
      if (keys.s) dy += 1;
      if (keys.a) dx -= 1;
      if (keys.d) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len; dy /= len;
        player.vx = dx * speed;
        player.vy = dy * speed;
      } else {
        player.vx = player.vy = 0;
      }

      moveEntity(player, dt);
    }

    function getCamera() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      const maxX = WORLD_W * TILE - canvas.width;
      const maxY = WORLD_H * TILE - canvas.height;
      camX = Math.max(0, Math.min(camX, maxX));
      camY = Math.max(0, Math.min(camY, maxY));
      return { x: camX, y: camY };
    }

    function applyFog(px, py) {
      ctx.save();
      // simple circular light – no cone in this test
      const radius = 220;
      const g = ctx.createRadialGradient(px, py, 0, px, py, radius);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(0.7, "rgba(0,0,0,0.4)");
      g.addColorStop(1, "rgba(0,0,0,0.95)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function render() {
      const cam = getCamera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startTX = Math.floor(cam.x / TILE);
      const startTY = Math.floor(cam.y / TILE);
      const endTX = Math.ceil((cam.x + canvas.width) / TILE);
      const endTY = Math.ceil((cam.y + canvas.height) / TILE);

      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) continue;
          const t = world[ty][tx];
          const dx = tx * TILE - cam.x;
          const dy = ty * TILE - cam.y;

          if (t === T_WALL) drawWall(tx, ty, dx, dy);
          else drawFloor(tx, ty, dx, dy);
        }
      }

      // player
      const px = player.x - cam.x;
      const py = player.y - cam.y;
      ctx.fillStyle = "#ffd04a";
      ctx.fillRect(px - 8, py - 8, 16, 16);

      applyFog(px, py);
    }

    let last = performance.now();
    function loop(t) {
      const dt = Math.min((t - last) / 1000, 0.05);
      last = t;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
