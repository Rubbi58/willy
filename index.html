<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hóriver – 100×100 Mansion Layout (Generated Tiles)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050104;
      color: #f7e3c8;
      overflow: hidden;
    }

    h1 {
      margin-top: 10px;
      text-align: center;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 18px;
      color: #ffdd88;
    }

    #subtitle {
      text-align: center;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-top: 4px;
      color: #ffbb66;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 90px);
    }

    canvas {
      border: 2px solid #ffcc66;
      background: #000;
      image-rendering: pixelated;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    #controls {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
      color: #ffe6bf;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>HÓRIVER’S LAIR – GENERATED TILE TEST</h1>
  <div id="subtitle">100×100 fixed layout • walls, rooms, furniture & candles (no sprites yet)</div>

  <div id="game-wrapper">
    <canvas id="game" width="800" height="800"></canvas>
    <div id="controls">
      Move with <b>W A S D</b>. Soft light around you. This version is just to check layout & tiles.
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const WORLD_W = 100;
    const WORLD_H = 100;

    // --- tile types ---
    const T_FLOOR    = 0;
    const T_WALL     = 1;
    const T_CLOSET   = 2;
    const T_CANDLE   = 3;
    const T_BED      = 4;
    const T_TABLE    = 5;
    const T_SHELF    = 6;
    const T_PIANO    = 7;
    const T_BATH     = 8;
    const T_TOILET   = 9;
    const T_SINK     = 10;
    const T_THRONE   = 11;
    const T_CARPET   = 12; // throne carpet strip

    // world grid
    const world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = new Array(WORLD_W).fill(T_WALL); // start as solid walls
      world.push(row);
    }

    // helper random but deterministic per coordinate
    function coordRand(x, y, seed = 1337) {
      let n = x * 374761393 + y * 668265263 + seed;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }

    function carveRoom(x0, y0, x1, y1) {
      for (let y = y0; y <= y1; y++) {
        for (let x = x0; x <= x1; x++) {
          if (x === x0 || x === x1 || y === y0 || y === y1) {
            world[y][x] = T_WALL;
          } else {
            world[y][x] = T_FLOOR;
          }
        }
      }
    }

    function carveCorridorX(y0, x0, x1, width = 4) {
      const yStart = y0 - Math.floor(width / 2);
      const yEnd = yStart + width - 1;
      for (let y = yStart; y <= yEnd; y++) {
        for (let x = Math.min(x0, x1); x <= Math.max(x0, x1); x++) {
          world[y][x] = T_FLOOR;
        }
      }
    }

    function carveCorridorY(x0, y0, y1, width = 4) {
      const xStart = x0 - Math.floor(width / 2);
      const xEnd = xStart + width - 1;
      for (let x = xStart; x <= xEnd; x++) {
        for (let y = Math.min(y0, y1); y <= Math.max(y0, y1); y++) {
          world[y][x] = T_FLOOR;
        }
      }
    }

    // === Layout design ===
    // Outer boundary room
    carveRoom(2, 2, 97, 97);

    // Entrance hallway at bottom center (4 wide, not too long)
    carveCorridorY(50, 80, 60, 4); // vertical bit inside
    carveCorridorY(50, 97, 80, 4); // down to edge (like front door)

    // Main central hall
    carveRoom(40, 40, 60, 60);

    // Throne room at top center
    carveRoom(40, 10, 60, 30);

    // Bedrooms left
    carveRoom(10, 40, 30, 60);
    carveRoom(10, 20, 30, 38);

    // Dining room right
    carveRoom(70, 40, 90, 60);

    // Kitchen near dining
    carveRoom(70, 20, 90, 38);

    // Library left-top
    carveRoom(10, 10, 30, 30);

    // Bathroom near throne
    carveRoom(65, 10, 80, 30);

    // Corridors linking rooms to main hall (4 wide)
    // Bedrooms ↔ main hall
    carveCorridorX(50, 30, 40, 4);
    carveCorridorX(30, 30, 40, 4);

    // Dining ↔ main hall
    carveCorridorX(50, 60, 70, 4);
    carveCorridorX(30, 60, 70, 4);

    // Throne ↔ main hall
    carveCorridorY(50, 30, 40, 4);

    // Bathroom ↔ throne room
    carveCorridorX(20, 60, 65, 3);

    // Library ↔ upper bedroom
    carveCorridorY(20, 30, 40, 3);

    // === Furniture helpers ===
    function placeTile(x, y, type) {
      if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return;
      world[y][x] = type;
    }

    function placeBedLeft(x, y) {
      placeTile(x, y, T_BED);
      placeTile(x, y + 1, T_BED);
    }

    function placeBedRight(x, y) {
      placeTile(x, y, T_BED);
      placeTile(x, y + 1, T_BED);
    }

    function placeTableHoriz(x0, y, length) {
      for (let x = x0; x < x0 + length; x++) {
        placeTile(x, y, T_TABLE);
      }
    }

    function placeShelvesVertical(x, y0, y1) {
      for (let y = y0; y <= y1; y++) {
        placeTile(x, y, T_SHELF);
      }
    }

    function placeCloset(x, y) {
      placeTile(x, y, T_CLOSET);
    }

    function placeCandle(x, y) {
      placeTile(x, y, T_CANDLE);
    }

    function placeBathroomSet(x, y) {
      // simple cluster: bath, toilet, sink
      placeTile(x, y,     T_BATH);
      placeTile(x + 2, y, T_TOILET);
      placeTile(x + 4, y, T_SINK);
    }

    // === Furnish rooms ===

    // Bedrooms
    placeBedLeft(12, 42);
    placeBedLeft(12, 52);
    placeBedRight(26, 42);
    placeBedRight(26, 52);
    placeCloset(15, 45);
    placeCloset(25, 55);

    // Upper bedroom
    placeBedLeft(12, 22);
    placeCloset(25, 25);

    // Library
    placeShelvesVertical(11, 11, 29);
    placeShelvesVertical(29, 11, 29);
    placeShelvesVertical(20, 11, 29);

    // Dining room: long table with chairs hinted by table tiles
    placeTableHoriz(72, 48, 16);
    placeCloset(88, 43); // coat closet

    // Kitchen: stoves/counters approximated with tables + shelves
    placeTableHoriz(72, 26, 8);
    placeShelvesVertical(88, 22, 36);

    // Bathroom
    placeBathroomSet(67, 18);
    placeCloset(78, 26);

    // Throne room: carpet + throne
    for (let y = 30; y <= 40; y++) {
      placeTile(49, y, T_CARPET);
      placeTile(50, y, T_CARPET);
      placeTile(51, y, T_CARPET);
    }
    placeTile(49, 12, T_THRONE);
    placeTile(50, 12, T_THRONE);
    placeTile(51, 12, T_THRONE);

    // Closets in main hall
    placeCloset(42, 42);
    placeCloset(58, 57);

    // Candles on some walls (throne, library, dining, corridors)
    for (let x = 42; x <= 58; x += 4) placeCandle(x, 10);
    for (let y = 12; y <= 28; y += 4) placeCandle(10, y);
    for (let y = 12; y <= 28; y += 4) placeCandle(30, y);
    for (let x = 72; x <= 88; x += 4) placeCandle(x, 40);
    for (let y = 42; y <= 58; y += 4) placeCandle(40, y);
    for (let y = 42; y <= 58; y += 4) placeCandle(60, y);

    // === Player & camera ===
    let player = {
      x: (50 + 0.5) * TILE,
      y: (90 + 0.5) * TILE,
      vx: 0,
      vy: 0
    };

    const keys = { w: false, a: false, s: false, d: false };

    window.addEventListener("keydown", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
    });

    window.addEventListener("keyup", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    function tileAt(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
      return world[ty][tx];
    }

    function isWalkable(tx, ty) {
      const t = tileAt(tx, ty);
      // everything except solid walls is walkable for now
      return t !== T_WALL;
    }

    function moveEntity(ent, dt) {
      const nextX = ent.x + ent.vx * dt;
      const nextY = ent.y + ent.vy * dt;

      const txNewX = Math.floor(nextX / TILE);
      const tyCur  = Math.floor(ent.y / TILE);
      if (isWalkable(txNewX, tyCur)) ent.x = nextX;

      const txCur  = Math.floor(ent.x / TILE);
      const tyNewY = Math.floor(nextY / TILE);
      if (isWalkable(txCur, tyNewY)) ent.y = nextY;
    }

    function update(dt) {
      const speed = 140;
      let dx = 0, dy = 0;
      if (keys.w) dy -= 1;
      if (keys.s) dy += 1;
      if (keys.a) dx -= 1;
      if (keys.d) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len; dy /= len;
        player.vx = dx * speed;
        player.vy = dy * speed;
      } else {
        player.vx = player.vy = 0;
      }

      moveEntity(player, dt);
    }

    function getCamera() {
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      const maxX = WORLD_W * TILE - canvas.width;
      const maxY = WORLD_H * TILE - canvas.height;
      camX = Math.max(0, Math.min(camX, maxX));
      camY = Math.max(0, Math.min(camY, maxY));
      return { x: camX, y: camY };
    }

    function drawTile(type, dx, dy) {
      // base floor cobble style
      if (type === T_FLOOR || type === T_CLOSET || type === T_CANDLE ||
          type === T_BED || type === T_TABLE || type === T_SHELF ||
          type === T_PIANO || type === T_BATH || type === T_TOILET ||
          type === T_SINK || type === T_THRONE || type === T_CARPET) {
        const r = coordRand(dx, dy);
        ctx.fillStyle = r < 0.5 ? "#202026" : "#252930";
        ctx.fillRect(dx, dy, TILE, TILE);
        ctx.strokeStyle = "#2d3036";
        ctx.strokeRect(dx + 0.5, dy + 0.5, TILE - 1, TILE - 1);
      }

      switch (type) {
        case T_WALL:
          ctx.fillStyle = "#3b272a";
          ctx.fillRect(dx, dy, TILE, TILE);
          ctx.strokeStyle = "#7e5555";
          ctx.strokeRect(dx + 0.5, dy + 0.5, TILE - 1, TILE - 1);
          break;
        case T_CLOSET:
          ctx.fillStyle = "#184854";
          ctx.fillRect(dx + 4, dy + 4, TILE - 8, TILE - 8);
          break;
        case T_CANDLE:
          ctx.fillStyle = "#f9e28f";
          ctx.fillRect(dx + TILE / 2 - 2, dy + 4, 4, 8);
          ctx.fillStyle = "#fffbcc";
          ctx.fillRect(dx + TILE / 2 - 1, dy + 2, 2, 3);
          break;
        case T_BED:
          ctx.fillStyle = "#7a4d3b";
          ctx.fillRect(dx + 4, dy + 4, TILE - 8, TILE - 8);
          ctx.fillStyle = "#c5c5d8";
          ctx.fillRect(dx + 6, dy + 6, TILE - 12, TILE - 14);
          break;
        case T_TABLE:
          ctx.fillStyle = "#8b5a2b";
          ctx.fillRect(dx + 2, dy + 6, TILE - 4, TILE - 12);
          break;
        case T_SHELF:
          ctx.fillStyle = "#6c4b2a";
          ctx.fillRect(dx + 3, dy + 3, TILE - 6, TILE - 6);
          ctx.fillStyle = "#d4a968";
          ctx.fillRect(dx + 5, dy + 6, TILE - 10, 4);
          ctx.fillRect(dx + 5, dy + 14, TILE - 10, 4);
          break;
        case T_PIANO:
          ctx.fillStyle = "#111111";
          ctx.fillRect(dx + 2, dy + 4, TILE - 4, TILE - 8);
          ctx.fillStyle = "#f5f5f5";
          ctx.fillRect(dx + 4, dy + 10, TILE - 8, 4);
          break;
        case T_BATH:
          ctx.fillStyle = "#4f7f90";
          ctx.fillRect(dx + 4, dy + 4, TILE - 8, TILE - 8);
          break;
        case T_TOILET:
          ctx.fillStyle = "#cfd3dd";
          ctx.fillRect(dx + 6, dy + 8, TILE - 12, TILE - 10);
          ctx.fillRect(dx + 10, dy + 4, TILE - 20, 4);
          break;
        case T_SINK:
          ctx.fillStyle = "#d8dde7";
          ctx.fillRect(dx + 6, dy + 6, TILE - 12, TILE - 12);
          break;
        case T_THRONE:
          ctx.fillStyle = "#c2983b";
          ctx.fillRect(dx + 4, dy + 6, TILE - 8, TILE - 10);
          ctx.fillStyle = "#f0e4a1";
          ctx.fillRect(dx + 6, dy + 8, TILE - 12, TILE - 14);
          break;
        case T_CARPET:
          ctx.fillStyle = "#25633a";
          ctx.fillRect(dx + 4, dy + 4, TILE - 8, TILE - 8);
          break;
      }
    }

    function applyFog(px, py) {
      ctx.save();
      const radius = 260;
      const g = ctx.createRadialGradient(px, py, 0, px, py, radius);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(0.7, "rgba(0,0,0,0.35)");
      g.addColorStop(1, "rgba(0,0,0,0.97)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function render() {
      const cam = getCamera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const startTX = Math.floor(cam.x / TILE);
      const startTY = Math.floor(cam.y / TILE);
      const endTX = Math.ceil((cam.x + canvas.width) / TILE);
      const endTY = Math.ceil((cam.y + canvas.height) / TILE);

      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) continue;
          const t = tileAt(tx, ty);
          const dx = tx * TILE - cam.x;
          const dy = ty * TILE - cam.y;
          drawTile(t, dx, dy);
        }
      }

      // player
      const px = player.x - cam.x;
      const py = player.y - cam.y;
      ctx.fillStyle = "#ffd04a";
      ctx.fillRect(px - 8, py - 8, 16, 16);

      applyFog(px, py);
    }

    let last = performance.now();
    function loop(t) {
      const dt = Math.min((t - last) / 1000, 0.05);
      last = t;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
