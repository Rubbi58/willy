<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8" />
 <title>Communism Party – Hóriver's Lair (Prototype)</title>
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <style>
 * {
 box-sizing: border-box;
 margin: 0;
 padding: 0;
 font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
 }
 body {
 background: #050104;
 color: #f7e3c8;
 overflow: hidden;
 }
 h1 {
 margin-top: 10px;
 text-align: center;
 letter-spacing: 0.18em;
 text-transform: uppercase;
 font-size: 18px;
 color: #ffdd88;
 }
 #subtitle {
 text-align: center;
 font-size: 13px;
 text-transform: uppercase;
 letter-spacing: 0.12em;
 margin-top: 4px;
 color: #ffbb66;
 }
 #game-wrapper {
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 height: calc(100vh - 90px);
 }
 canvas {
 border: 2px solid #ffcc66;
 background: #000;
 image-rendering: pixelated;
 box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
 }
 #controls {
 margin-top: 8px;
 font-size: 13px;
 opacity: 0.9;
 color: #ffe6bf;
 text-align: center;
 }
 #interactionPrompt {
 margin-top: 4px;
 font-size: 13px;
 text-align: center;
 color: #ffdd88;
 min-height: 18px;
 }
 .overlay {
 position: fixed;
 inset: 0;
 display: none;
 align-items: center;
 justify-content: center;
 background: rgba(0, 0, 0, 0.88);
 z-index: 40;
 }
 .overlay.active {
 display: flex;
 }
 .overlay-card {
 border-radius: 1.4rem;
 border: 2px solid #ffcc66;
 background: radial-gradient(circle at top, #4b0000 0, #050104 60%);
 padding: 1.6rem 2rem 1.8rem;
 max-width: 480px;
 text-align: center;
 color: #ffe6bf;
 box-shadow: 0 26px 70px rgba(0, 0, 0, 0.9);
 }
 .overlay-card img {
 max-width: 260px;
 image-rendering: pixelated;
 border-radius: 0.7rem;
 margin-bottom: 0.9rem;
 }
 .overlay-title {
 font-size: 1.4rem;
 letter-spacing: 0.16em;
 text-transform: uppercase;
 color: #ffdd88;
 margin-bottom: 0.5rem;
 }
 .overlay-sub {
 font-size: 0.92rem;
 margin-bottom: 1.1rem;
 }
 .btn {
 cursor: pointer;
 border-radius: 999px;
 padding: 0.6rem 1.5rem;
 font-size: 0.85rem;
 text-transform: uppercase;
 letter-spacing: 0.12em;
 border: none;
 margin: 0 0.4rem;
 }
 .btn-primary {
 background: linear-gradient(135deg, #ffcc66, #ff4848);
 color: #3b0000;
 font-weight: 800;
 box-shadow: 0 14px 28px rgba(0, 0, 0, 0.7);
 }
 .btn-primary:hover {
 filter: brightness(1.06);
 }
 #alertBanner {
 position: fixed;
 left: 50%;
 top: 10%;
 transform: translateX(-50%);
 padding: 0.5rem 1.1rem;
 border-radius: 999px;
 border: 1px solid #ff4444;
 background: rgba(60, 0, 0, 0.93);
 color: #ffdddd;
 font-size: 0.82rem;
 letter-spacing: 0.16em;
 text-transform: uppercase;
 text-align: center;
 display: none;
 z-index: 25;
 box-shadow: 0 10px 24px rgba(0, 0, 0, 0.8);
 }
 #welcomeOverlay img {
 max-width: 280px;
 }
 #welcomeHint {
 margin-top: 0.8rem;
 font-size: 0.8rem;
 opacity: 0.7;
 }
 @media (max-width: 900px) {
 #game-wrapper {
 transform: scale(0.85);
 }
 .overlay-card {
 margin: 0 1rem;
 padding-inline: 1.4rem;
 }
 }
 </style>
</head>
<body>
 <h1>HÓRIVER’S LAIR – LEVEL 1 (PROTOTYPE)</h1>
 <div id="subtitle">
 Mission: find the flashlight, key, vape and bathroom in Hóriver’s cursed mansion–castle
 </div>
 <div id="game-wrapper">
 <canvas id="game" width="800" height="600"></canvas>
 <div id="controls">
 Move with <b>W A S D</b>. <b>R</b> = interact (pick up, flush, claim). <b>F</b> = hide in closets. Closets only protect you while h </div>
 <div id="interactionPrompt"></div>
 </div>
 <div id="alertBanner">HÓRIVER HEARS YOU</div>
 <!-- WELCOME OVERLAY WITH TYPEWRITER -->
 <div id="welcomeOverlay" class="overlay active">
 <div class="overlay-card" id="welcomeCard">
 <div id="welcomeTextWrapper">
 <div class="overlay-title">COMMUNISM PARTY HQ</div>
 <div class="overlay-sub" id="welcomeText"></div>
 <div id="welcomeHint">Click this box to continue...</div>
 </div>
 <div id="welcomeFinal" style="display:none;">
 <img src="images/horiver-lair.png" alt="Horiver's Lair" />
 <div class="overlay-title">HORIVER'S LAIR</div>
 <div class="overlay-sub">Enter the cursed vape castle.</div>
 <button class="btn btn-primary" id="enterBtn">Enter</button>
 </div>
 </div>
 </div>
 <!-- Death overlay -->
 <div id="deathOverlay" class="overlay">
 <div class="overlay-card">
 <img src="images/horiver-jumpscare.png" alt="Horiver Jumpscare" />
 <div class="overlay-title" style="color:#ff5555;">WASTED</div>
 <div class="overlay-sub">
 Hóriver caught you in the fog. The castle reeks of vape forever.
 </div>
 <button class="btn btn-primary" id="retryBtn">Retry Level</button>
 </div>
 </div>
 <!-- Win overlay -->
 <div id="winOverlay" class="overlay">
 <div class="overlay-card">
 <img src="images/bhoriver-token.png" alt="Token" />
 <div class="overlay-title">MISSION COMPLETE</div>
 <div class="overlay-sub">
 The vape is flushed. Hóriver screams and dissolves into communist vapor. You claim your cursed token.
 </div>
 <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
 </div>
 </div>
 <script>
 // ===== Helpers =====
 function makeImage(name) {
 const img = new Image();
 img.src = "images/" + encodeURIComponent(name);
 return img;
 }
 function makeSound(name, loop = false, volume = 1) {
 const a = new Audio("sounds/" + encodeURIComponent(name));
 a.loop = loop;
 a.volume = volume;
 return a;
 }
 function safePlay(a) {
 a.currentTime = 0;
 a.play().catch(() => {});
 }
 // ===== Canvas & world =====
 const canvas = document.getElementById("game");
 const ctx = canvas.getContext("2d");
 const TILE = 32;
 const WORLD_W = 24;
 const WORLD_H = 24;
 const playerSpeed = 120;
 const horiverBaseSpeed = 90;
 const T_WALL = 1;
 const T_FLOOR = 0;
 const T_CLOSET = 2;
 const T_THRONE = 3;
 const T_KEY = 4;
 const T_CHEST = 5;
 const T_BATHROOM = 6;
 const T_FLASHLIGHT = 7;
 const T_START = 8;
 const world = [];
 for (let y = 0; y < WORLD_H; y++) {
 const row = new Array(WORLD_W).fill(T_WALL);
 world.push(row);
 }
 function carveRect(x0, y0, x1, y1, type = T_FLOOR) {
 for (let y = y0; y <= y1; y++) {
 for (let x = x0; x <= x1; x++) {
 if (x > 0 && y > 0 && x < WORLD_W - 1 && y < WORLD_H - 1) {
 world[y][x] = type;
 }
 }
 }
 }
 // ===== Small prototype layout (castle + mansion) =====
 function generatePrototypeMap() {
 // central area
 carveRect(2, 2, WORLD_W - 3, WORLD_H - 3);
 // entrance hall (bottom)
 carveRect(4, WORLD_H - 6, 10, WORLD_H - 3);
 world[WORLD_H - 5][5] = T_START;
 // corridor up from entrance
 carveRect(6, WORLD_H - 7, 6, 13);
 // horizontal corridor to center
 carveRect(6, 13, 16, 13);
 // main central hall
 carveRect(10, 6, 18, 16);
 // throne room (top center)
 carveRect(10, 3, 18, 6);
 world[4][14] = T_THRONE;
 // bedroom (left of hall)
 carveRect(3, 6, 9, 11);
 // dining room (right of hall)
 carveRect(19, 6, 22, 12);
 // bathroom (top-right)
 carveRect(19, 3, 22, 5);
 world[4][20] = T_BATHROOM;
 // chest room (bottom-right of hall)
 carveRect(19, 14, 22, 18);
 world[16][20] = T_CHEST;
 // flashlight in bedroom
 world[8][5] = T_FLASHLIGHT;
 // key in dining room
 world[8][21] = T_KEY;
 // closets (safe zones)
 world[WORLD_H - 5][8] = T_CLOSET; // entrance closet
 world[11][12] = T_CLOSET; // central closet
 world[15][19] = T_CLOSET; // near chest
 }
 generatePrototypeMap();
 function tileAt(tx, ty) {
 if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
 return world[ty][tx];
 }
 function isWalkable(tx, ty) {
 return tileAt(tx, ty) !== T_WALL;
 }
 function findTile(type) {
 for (let y = 0; y < WORLD_H; y++) {
 for (let x = 0; x < WORLD_W; x++) {
 if (world[y][x] === type) return { x, y };
 }
 }
 return null;
 }
 // ===== Assets =====
 const imgPlayer = makeImage("player.png");
 const imgHoriver = makeImage("horiver-character.png");
 const imgFlashlight = makeImage("pixel-flashlight.png");
 const imgKey = makeImage("key pixel.png");
 const imgVape = makeImage("vape pixel.png");
 const imgFurniture = makeImage("furniture.png");
 const sounds = {
 bgm: makeSound("backg-music.mp3", true, 0.45),
 start: makeSound("start-sound.mp3"),
 menuClick: makeSound("menu-click.mp3"),
 pickup: makeSound("item-pickup.mp3"),
 door: makeSound("door-open.mp3"),
 flush: makeSound("toilet-flush.mp3"),
 jumpscare: makeSound("jumpscare.mp3"),
 win: makeSound("win.mp3"),
 deathScream: makeSound("horiver-death-scream.mp3")
 };
 let musicStarted = false;
 function startMusicOnce() {
 if (!musicStarted) {
 musicStarted = true;
 safePlay(sounds.bgm);
 }
 }
 // ===== Game state =====
 let player = { x: 0, y: 0, vx: 0, vy: 0 };
 let horiver = { x: 0, y: 0, vx: 0, vy: 0, active: false, alive: true };
 let horiverFacing = { x: 0, y: 1 }; // for vision cone
 let keys = { w: false, a: false, s: false, d: false };
 let lastDir = { x: 0, y: 1 };
 let haveFlashlight = false;
 let haveKey = false;
 let haveVape = false;
 let vapeDestroyed = false;
 let gameOver = false;
 let win = false;
 // stealth / rage
 let playerHidden = false;
 let closetNearby = false;
 let closetTile = null;
 let horiverEnraged = false;
 // interaction system (press R / F)
 let interactionPrompt = "";
 let interactionAction = null;
 const interactionEl = document.getElementById("interactionPrompt");
 function clearInteraction() {
 interactionPrompt = "";
 interactionAction = null;
 interactionEl.textContent = "";
 }
 function resetGame() {
 const startTile = findTile(T_START) || { x: 5, y: WORLD_H - 5 };
 player.x = (startTile.x + 0.5) * TILE;
 player.y = (startTile.y + 0.5) * TILE;
 player.vx = player.vy = 0;
 const throneTile = findTile(T_THRONE) || { x: 14, y: 4 };
 horiver.x = (throneTile.x + 0.5) * TILE;
 horiver.y = (throneTile.y + 0.5) * TILE;
 horiver.vx = horiver.vy = 0;
 horiver.active = false;
 horiver.alive = true;
 horiverFacing = { x: 0, y: 1 };
 haveFlashlight = false;
 haveKey = false;
 haveVape = false;
 vapeDestroyed = false;
 gameOver = false;
 win = false;
 playerHidden = false;
 closetNearby = false;
 closetTile = null;
 horiverEnraged = false;
 document.getElementById("subtitle").textContent =
 "Mission: find the flashlight, key, vape and bathroom in Hóriver’s cursed mansion–castle";
 hideAlert();
 clearInteraction();
 }
 // ===== Input =====
 window.addEventListener("keydown", (e) => {
 const k = e.key.toLowerCase();
 if (k === "w") keys.w = true;
 if (k === "s") keys.s = true;
 if (k === "a") keys.a = true;
 if (k === "d") keys.d = true;
 if (k === "f") {
 if (
 !document.getElementById("welcomeOverlay").classList.contains("active") &&
 !gameOver &&
 !win
 ) {
 toggleHideInCloset();
 }
 }
 if (k === "r") {
 if (
 interactionAction &&
 !document.getElementById("welcomeOverlay").classList.contains("active") &&
 !gameOver &&
 !win
 ) {
 const fn = interactionAction;
 interactionAction = null;
 interactionPrompt = "";
 interactionEl.textContent = "";
 fn();
 }
 }
 });
 window.addEventListener("keyup", (e) => {
 const k = e.key.toLowerCase();
 if (k === "w") keys.w = false;
 if (k === "s") keys.s = false;
 if (k === "a") keys.a = false;
 if (k === "d") keys.d = false;
 });
 // ===== Alert banner =====
 function showAlert() {
 const el = document.getElementById("alertBanner");
 el.style.display = "block";
 setTimeout(() => { el.style.display = "none"; }, 2000);
 }
 function hideAlert() {
 document.getElementById("alertBanner").style.display = "none";
 }
 function awakenHoriver() {
 if (!horiver.active && horiver.alive) {
 horiver.active = true;
 showAlert();
 safePlay(sounds.jumpscare);
 }
 }
 function isCloset(tx, ty) {
 return tileAt(tx, ty) === T_CLOSET;
 }
 // helper: find nearby tiles of certain types within a radius (pixels)
 function findNearbyTile(types, px, py, range = 48) {
 const tx = Math.floor(px / TILE);
 const ty = Math.floor(py / TILE);
 let best = null;
 let bestDist = Infinity;
 for (let dy = -1; dy <= 1; dy++) {
 for (let dx = -1; dx <= 1; dx++) {
 const nx = tx + dx;
 const ny = ty + dy;
 const tile = tileAt(nx, ny);
 if (types.includes(tile)) {
 const cx = (nx + 0.5) * TILE;
 const cy = (ny + 0.5) * TILE;
 const d = Math.hypot(px - cx, py - cy);
 if (d < range && d < bestDist) {
 bestDist = d;
 best = { x: nx, y: ny, tile };
 }
 }
 }
 }
 return best;
 }
 function pickupCheck() {
 clearInteraction();
 const px = player.x;
 const py = player.y;
 // Nearby items
 const near = findNearbyTile(
 [T_FLASHLIGHT, T_KEY, T_CHEST, T_BATHROOM, T_THRONE],
 px, py, 48
 );
 if (near) {
 const { x: tx, y: ty, tile: t } = near;
 // flashlight
 if (t === T_FLASHLIGHT && !haveFlashlight) {
 interactionPrompt = 'Press R to pick up flashlight';
 interactionAction = () => {
 haveFlashlight = true;
 world[ty][tx] = T_FLOOR;
 safePlay(sounds.pickup);
 document.getElementById("subtitle").textContent =
 "Mission: find the key to Hóriver’s chest";
 };
 }
 // key
 if (t === T_KEY && !haveKey) {
 interactionPrompt = 'Press R to pick up key';
 interactionAction = () => {
 haveKey = true;
 world[ty][tx] = T_FLOOR;
 safePlay(sounds.pickup);
 awakenHoriver();
 document.getElementById("subtitle").textContent =
 "Mission: reach the chest and steal the vape";
 };
 }
 // chest -> vape
 if (t === T_CHEST && haveKey && !haveVape && !vapeDestroyed) {
 interactionPrompt = 'Press R to steal Horiver\'s vape';
 interactionAction = () => {
 haveVape = true;
 safePlay(sounds.door);
 safePlay(sounds.pickup);
 document.getElementById("subtitle").textContent =
 "Mission: find the bathroom and flush the vape";
 };
 }
 // bathroom flush
 if (t === T_BATHROOM && haveVape && !vapeDestroyed) {
 interactionPrompt = 'Press R to flush the vape';
 interactionAction = () => {
 haveVape = false;
 vapeDestroyed = true;
 safePlay(sounds.flush);
 safePlay(sounds.deathScream);
 horiver.alive = false;
 horiver.active = false;
 document.getElementById("subtitle").textContent =
 "Mission: return to the throne to claim your reward";
 };
 }
 // throne -> finish
 if (t === T_THRONE && vapeDestroyed && !win) {
 interactionPrompt = 'Press R to claim your reward';
 interactionAction = () => {
 finishLevel();
 };
 }
 }
 // closet detection (for F)
 closetNearby = false;
 closetTile = null;
 const nearCloset = findNearbyTile([T_CLOSET], px, py, 56);
 if (nearCloset) {
 closetNearby = true;
 closetTile = { x: nearCloset.x, y: nearCloset.y };
 const closetMsg = playerHidden
 ? "Press F to leave closet"
 : "Press F to hide in closet";
 if (!interactionPrompt) {
 interactionPrompt = closetMsg;
 } else {
 interactionPrompt += " | " + closetMsg;
 }
 }
 interactionEl.textContent = interactionPrompt;
 }
 function finishLevel() {
 win = true;
 safePlay(sounds.win);
 document.getElementById("winOverlay").classList.add("active");
 clearInteraction();
 }
 function killPlayer() {
 if (gameOver || win) return;
 gameOver = true;
 safePlay(sounds.jumpscare);
 document.getElementById("deathOverlay").classList.add("active");
 clearInteraction();
 }
 function moveEntity(ent, dt) {
 const nextX = ent.x + ent.vx * dt;
 const nextY = ent.y + ent.vy * dt;
 const txNewX = Math.floor(nextX / TILE);
 const tyCur = Math.floor(ent.y / TILE);
 if (isWalkable(txNewX, tyCur)) ent.x = nextX;
 else ent.vx = 0;
 const txCur = Math.floor(ent.x / TILE);
 const tyNewY = Math.floor(nextY / TILE);
 if (isWalkable(txCur, tyNewY)) ent.y = nextY;
 else ent.vy = 0;
 }
 function toggleHideInCloset() {
 // leave closet
 if (playerHidden) {
 playerHidden = false;
 interactionPrompt = "";
 interactionEl.textContent = "";
 return;
 }
 // enter closet
 if (!closetNearby || !closetTile) return;
 playerHidden = true;
 player.x = (closetTile.x + 0.5) * TILE;
 player.y = (closetTile.y + 0.5) * TILE;
 player.vx = player.vy = 0;
 horiverEnraged = false; // lose the lock when you hide
 interactionPrompt = "Hidden in closet. Press F to leave.";
 interactionEl.textContent = interactionPrompt;
 }
 function updateMovement(dt) {
 if (playerHidden) {
 player.vx = player.vy = 0;
 pickupCheck(); // still update F prompt etc.
 return;
 }
 let dx = 0, dy = 0;
 if (keys.w) dy -= 1;
 if (keys.s) dy += 1;
 if (keys.a) dx -= 1;
 if (keys.d) dx += 1;
 if (dx !== 0 || dy !== 0) {
 const len = Math.hypot(dx, dy);
 dx /= len; dy /= len;
 player.vx = dx * playerSpeed;
 player.vy = dy * playerSpeed;
 lastDir.x = dx;
 lastDir.y = dy;
 } else {
 player.vx = player.vy = 0;
 }
 moveEntity(player, dt);
 pickupCheck();
 }
 function updateHoriver(dt) {
 if (!horiver.active || !horiver.alive) return;
 const dx = player.x - horiver.x;
 const dy = player.y - horiver.y;
 const dist = Math.hypot(dx, dy) || 1;
 // update facing whenever he moves
 const dirX = dx / dist;
 const dirY = dy / dist;
 if (dist > 1) {
 horiverFacing.x = dirX;
 horiverFacing.y = dirY;
 }
 // vision cone: slim but long, only matters if you have the vape and aren't hidden
 if (!horiverEnraged && haveVape && !playerHidden) {
 const maxRange = 260;
 if (dist < maxRange) {
 const toPlayerX = dx / dist;
 const toPlayerY = dy / dist;
 const dot =
 toPlayerX * horiverFacing.x + toPlayerY * horiverFacing.y; // cos(angle)
 const coneCos = Math.cos(20 * Math.PI / 180); // ~0.94, narrow
 if (dot > coneCos) {
 horiverEnraged = true;
 showAlert();
 }
 }
 }
 const speed = horiverEnraged ? horiverBaseSpeed * 1.5 : horiverBaseSpeed;
 if (dist > 1) {
 horiver.vx = dirX * speed;
 horiver.vy = dirY * speed;
 } else {
 horiver.vx = horiver.vy = 0;
 }
 moveEntity(horiver, dt);
 const ptx = Math.floor(player.x / TILE);
 const pty = Math.floor(player.y / TILE);
 const htx = Math.floor(horiver.x / TILE);
 const hty = Math.floor(horiver.y / TILE);
 if (ptx === htx && pty === hty && !playerHidden && !vapeDestroyed) {
 killPlayer();
 }
 }
 function getCamera() {
 let camX = player.x - canvas.width / 2;
 let camY = player.y - canvas.height / 2;
 const maxX = WORLD_W * TILE - canvas.width;
 const maxY = WORLD_H * TILE - canvas.height;
 camX = Math.max(0, Math.min(camX, maxX));
 camY = Math.max(0, Math.min(camY, maxY));
 return { x: camX, y: camY };
 }
 // Draw a 32×32 furniture tile from furniture.png at some source coords
 function drawFurnitureTile(sx, sy, dx, dy) {
 if (!imgFurniture.complete || !imgFurniture.naturalWidth) return;
 ctx.drawImage(imgFurniture, sx, sy, 32, 32, dx, dy, TILE, TILE);
 }
 function render() {
 const cam = getCamera();
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 const startTX = Math.floor(cam.x / TILE);
 const startTY = Math.floor(cam.y / TILE);
 const endTX = Math.ceil((cam.x + canvas.width) / TILE);
 const endTY = Math.ceil((cam.y + canvas.height) / TILE);
 // ---- draw tiles & some furniture ----
 for (let ty = startTY; ty <= endTY; ty++) {
 for (let tx = startTX; tx <= endTX; tx++) {
 const t = tileAt(tx, ty);
 const sx = tx * TILE - cam.x;
 const sy = ty * TILE - cam.y;
 if (t === T_WALL) {
 ctx.fillStyle = "#261014"; // wall
 } else if (t === T_CLOSET) {
 ctx.fillStyle = "#044b55"; // safe closet
 } else if (t === T_BATHROOM) {
 ctx.fillStyle = "#325c7a"; // bathroom
 } else {
 ctx.fillStyle = "#120509"; // floor
 }
 ctx.fillRect(sx, sy, TILE, TILE);
 if (t === T_THRONE) {
 ctx.fillStyle = "#c28b3b";
 ctx.fillRect(sx + 4, sy + 4, TILE - 8, TILE - 8);
 }
 // simple furniture examples
 if (tx === 21 && ty === 8) {
 drawFurnitureTile(0, 0, sx, sy); // table/sofa
 }
 if (tx === 5 && ty === 8) {
 drawFurnitureTile(96, 0, sx, sy); // bed/couch
 }
 if (tx === 20 && ty === 4) {
 drawFurnitureTile(0, 160, sx, sy); // toilet/fixture
 }
 }
 }
 function drawSprite(img, gx, gy, scale = 0.9) {
 const screenX = gx * TILE - cam.x;
 const screenY = gy * TILE - cam.y;
 const size = TILE * scale;
 const dx = screenX + (TILE - size) / 2;
 const dy = screenY + (TILE - size) / 2;
 if (screenX + TILE < 0 || screenY + TILE < 0 ||
 screenX > canvas.width || screenY > canvas.height) return;
 if (img.complete && img.naturalWidth) {
 ctx.drawImage(img, dx, dy, size, size);
 } else {
 ctx.fillStyle = "#0cf";
 ctx.fillRect(dx, dy, size, size);
 }
 }
 // ---- items (with key glow) ----
 for (let ty = startTY; ty <= endTY; ty++) {
 for (let tx = startTX; tx <= endTX; tx++) {
 const t = tileAt(tx, ty);
 const sxItem = tx * TILE - cam.x;
 const syItem = ty * TILE - cam.y;
 if (t === T_FLASHLIGHT && !haveFlashlight) {
 drawSprite(imgFlashlight, tx, ty, 0.95);
 }
 if (t === T_KEY && !haveKey) {
 ctx.fillStyle = "#ffd54a";
 ctx.fillRect(sxItem + 6, syItem + 6, TILE - 12, TILE - 12);
 drawSprite(imgKey, tx, ty, 0.95);
 }
 if (t === T_CHEST && haveKey && !vapeDestroyed && !haveVape) {
 drawSprite(imgVape, tx, ty, 0.95);
 }
 }
 }
 // ---- player & horiver ----
 drawSprite(imgPlayer, player.x / TILE, player.y / TILE, 0.95);
 if (horiver.alive && horiver.active) {
 drawSprite(imgHoriver, horiver.x / TILE, horiver.y / TILE, 0.95);
 }
 applyFog(player.x - cam.x, player.y - cam.y);
 }
 // Proper fog + flashlight cone: dark everywhere, bright around player,
 // extra directional light once you have the flashlight.
 function applyFog(pScreenX, pScreenY) {
 // ---- 1) Darken whole screen ----
 ctx.save();
 ctx.fillStyle = "rgba(0, 0, 0, 0.94)";
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 // ---- 2) Carve out a circular field of view ----
 ctx.globalCompositeOperation = "destination-out";
 const baseInnerRadius = haveFlashlight ? 50 : 25;
 const baseOuterRadius = haveFlashlight ? 260 : 170;
 const g = ctx.createRadialGradient(
 pScreenX, pScreenY, baseInnerRadius,
 pScreenX, pScreenY, baseOuterRadius
 );
 g.addColorStop(0, "rgba(0,0,0,1)");
 g.addColorStop(0.7, "rgba(0,0,0,0.4)");
 g.addColorStop(1, "rgba(0,0,0,0)");
 ctx.fillStyle = g;
 ctx.beginPath();
 ctx.arc(pScreenX, pScreenY, baseOuterRadius, 0, Math.PI * 2);
 ctx.fill();
 ctx.restore();
 // ---- 3) Add warm "light" so the center actually looks brighter ----
 ctx.save();
 ctx.globalCompositeOperation = "lighter";
 const lightOuter = haveFlashlight ? 220 : 140;
 const lightInner = 10;
 const lg = ctx.createRadialGradient(
 pScreenX, pScreenY, lightInner,
 pScreenX, pScreenY, lightOuter
 );
 lg.addColorStop(0, "rgba(255, 230, 180, 0.85)");
 lg.addColorStop(0.4, "rgba(255, 230, 180, 0.35)");
 lg.addColorStop(1, "rgba(255, 230, 180, 0)");
 ctx.fillStyle = lg;
 ctx.beginPath();
 ctx.arc(pScreenX, pScreenY, lightOuter, 0, Math.PI * 2);
 ctx.fill();
 // ---- 4) Extra narrow flashlight cone once picked up ----
 if (haveFlashlight) {
 const dirX = lastDir.x || 0;
 const dirY = lastDir.y || 1;
 const coneLength = 260;
 const coneWidth = 90;
 const tipX = pScreenX + dirX * coneLength;
 const tipY = pScreenY + dirY * coneLength;
 const perpX = -dirY;
 const perpY = dirX;
 const leftX = pScreenX + perpX * (coneWidth * 0.5);
 const leftY = pScreenY + perpY * (coneWidth * 0.5);
 const rightX = pScreenX - perpX * (coneWidth * 0.5);
 const rightY = pScreenY - perpY * (coneWidth * 0.5);
 const coneGrad = ctx.createLinearGradient(pScreenX, pScreenY, tipX, tipY);
 coneGrad.addColorStop(0, "rgba(255, 245, 210, 0.9)");
 coneGrad.addColorStop(1, "rgba(255, 245, 210, 0)");
 ctx.fillStyle = coneGrad;
 ctx.beginPath();
 ctx.moveTo(leftX, leftY);
 ctx.lineTo(tipX, tipY);
 ctx.lineTo(rightX, rightY);
 ctx.closePath();
 ctx.fill();
 }
 ctx.restore();
 }
 // ===== Main loop =====
 let lastTime = performance.now();
 function loop(time) {
 const dt = Math.min((time - lastTime) / 1000, 0.05);
 lastTime = time;
 if (!gameOver && !win && !document.getElementById("welcomeOverlay").classList.contains("active")) {
 updateMovement(dt);
 updateHoriver(dt);
 render();
 }
 requestAnimationFrame(loop);
 }
 requestAnimationFrame(loop);
 // ===== Overlays & typewriter intro =====
 const welcomeOverlay = document.getElementById("welcomeOverlay");
 const welcomeCard = document.getElementById("welcomeCard");
 const welcomeTextEl = document.getElementById("welcomeText");
 const welcomeHintEl = document.getElementById("welcomeHint");
 const welcomeTextWrapper = document.getElementById("welcomeTextWrapper");
 const welcomeFinal = document.getElementById("welcomeFinal");
 const enterBtn = document.getElementById("enterBtn");
 const deathOverlay = document.getElementById("deathOverlay");
 const winOverlay = document.getElementById("winOverlay");
 const welcomeMessages = [
 "Welcome to Hubios communism party game. Your mission is to save communism Iceland, but first, you need to defeat some foes...",
 "Now you'll enter... Horivers lair!!!",
 "Are you ready?"
 ];
 let welcomeStep = 0;
 let typingIndex = 0;
 let typingTimer = null;
 let typingDone = false;
 function typeNextChar() {
 const msg = welcomeMessages[welcomeStep];
 if (typingIndex <= msg.length) {
 welcomeTextEl.textContent = msg.slice(0, typingIndex);
 typingIndex++;
 } else {
 clearInterval(typingTimer);
 typingTimer = null;
 typingDone = true;
 welcomeHintEl.textContent = "Click this box to continue...";
 }
 }
 function startTyping() {
 if (typingTimer) clearInterval(typingTimer);
 typingIndex = 0;
 typingDone = false;
 welcomeTextEl.textContent = "";
 welcomeHintEl.textContent = "";
 typingTimer = setInterval(typeNextChar, 35);
 }
 startTyping();
 welcomeCard.addEventListener("click", () => {
 startMusicOnce();
 if (!typingDone) {
 const msg = welcomeMessages[welcomeStep];
 clearInterval(typingTimer);
 typingTimer = null;
 typingDone = true;
 typingIndex = msg.length;
 welcomeTextEl.textContent = msg;
 welcomeHintEl.textContent = "Click this box to continue...";
 return;
 }
 welcomeStep++;
 if (welcomeStep < welcomeMessages.length) {
 startTyping();
 } else {
 welcomeTextWrapper.style.display = "none";
 welcomeFinal.style.display = "block";
 }
 });
 enterBtn.addEventListener("click", (e) => {
 e.stopPropagation();
 safePlay(sounds.menuClick);
 startMusicOnce();
 welcomeOverlay.classList.remove("active");
 resetGame();
 safePlay(sounds.start);
 });
 document.getElementById("retryBtn").addEventListener("click", () => {
 safePlay(sounds.menuClick);
 deathOverlay.classList.remove("active");
 resetGame();
 });
 document.getElementById("playAgainBtn").addEventListener("click", () => {
 safePlay(sounds.menuClick);
 winOverlay.classList.remove("active");
 resetGame();
 });
 // initial render
 render();
 </script>
</body>
</html>
