<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hóriver Mini – Wall Test (Fixed Light)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050104;
      color: #f7e3c8;
      overflow: hidden;
    }

    h1 {
      margin-top: 10px;
      text-align: center;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 18px;
      color: #ffdd88;
    }

    #subtitle {
      text-align: center;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-top: 4px;
      color: #ffbb66;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: calc(100vh - 90px);
    }

    canvas {
      border: 2px solid #ffcc66;
      background: #000;
      image-rendering: pixelated;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    #controls {
      margin-top: 8px;
      font-size: 13px;
      opacity: 0.9;
      color: #ffe6bf;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>HÓRIVER MINI – WALL TEST</h1>
  <div id="subtitle">20×20 map – just walls, floor and flashlight</div>

  <div id="game-wrapper">
    <canvas id="game" width="640" height="640"></canvas>
    <div id="controls">
      Move with <b>W A S D</b>. Aim flashlight with your mouse.
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const WORLD_W = 20;
    const WORLD_H = 20;

    const T_WALL  = 1;
    const T_FLOOR = 0;

    const world = [];
    for (let y = 0; y < WORLD_H; y++) {
      const row = [];
      for (let x = 0; x < WORLD_W; x++) {
        if (x === 0 || y === 0 || x === WORLD_W - 1 || y === WORLD_H - 1) {
          row.push(T_WALL);
        } else {
          row.push(T_FLOOR);
        }
      }
      world.push(row);
    }

    // inner room 1 (top-left)
    for (let y = 3; y <= 8; y++) {
      for (let x = 3; x <= 8; x++) {
        if (x === 3 || x === 8 || y === 3 || y === 8) world[y][x] = T_WALL;
        else world[y][x] = T_FLOOR;
      }
    }

    // inner room 2 (bottom-right)
    for (let y = 11; y <= 17; y++) {
      for (let x = 11; x <= 17; x++) {
        if (x === 11 || x === 17 || y === 11 || y === 17) world[y][x] = T_WALL;
        else world[y][x] = T_FLOOR;
      }
    }

    function tileAt(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= WORLD_W || ty >= WORLD_H) return T_WALL;
      return world[ty][tx];
    }

    function isWalkable(tx, ty) {
      return tileAt(tx, ty) !== T_WALL;
    }

    let player = {
      x: (WORLD_W / 2 + 0.5) * TILE,
      y: (WORLD_H / 2 + 0.5) * TILE,
      vx: 0,
      vy: 0
    };

    const keys = { w: false, a: false, s: false, d: false };
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    window.addEventListener("keydown", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
    });
    window.addEventListener("keyup", e => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    function moveEntity(ent, dt) {
      const nextX = ent.x + ent.vx * dt;
      const nextY = ent.y + ent.vy * dt;

      const txNewX = Math.floor(nextX / TILE);
      const tyCur  = Math.floor(ent.y / TILE);
      if (isWalkable(txNewX, tyCur)) ent.x = nextX;

      const txCur  = Math.floor(ent.x / TILE);
      const tyNewY = Math.floor(nextY / TILE);
      if (isWalkable(txCur, tyNewY)) ent.y = nextY;
    }

    function update(dt) {
      const speed = 120;
      let dx = 0, dy = 0;
      if (keys.w) dy -= 1;
      if (keys.s) dy += 1;
      if (keys.a) dx -= 1;
      if (keys.d) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len; dy /= len;
        player.vx = dx * speed;
        player.vy = dy * speed;
      } else {
        player.vx = player.vy = 0;
      }

      moveEntity(player, dt);
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // draw grid
      for (let y = 0; y < WORLD_H; y++) {
        for (let x = 0; x < WORLD_W; x++) {
          const t = world[y][x];
          const sx = x * TILE;
          const sy = y * TILE;

          if (t === T_WALL) {
            ctx.fillStyle = "#553333";
            ctx.fillRect(sx, sy, TILE, TILE);
            ctx.strokeStyle = "#aa7777";
            ctx.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
          } else {
            ctx.fillStyle = "#202026";
            ctx.fillRect(sx, sy, TILE, TILE);
            ctx.strokeStyle = "#2f2f35";
            ctx.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
          }
        }
      }

      // player
      ctx.fillStyle = "#ffd04a";
      ctx.fillRect(player.x - 8, player.y - 8, 16, 16);

      applyFog(player.x, player.y);
    }

    function applyFog(px, py) {
      ctx.save();

      // 1) Full darkness
      ctx.fillStyle = "rgba(0,0,0,0.88)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 2) Cut holes (light) out of darkness
      ctx.globalCompositeOperation = "destination-out";

      // Small aura around player
      const auraRadius = 90;
      ctx.beginPath();
      ctx.arc(px, py, auraRadius, 0, Math.PI * 2);
      ctx.fill();

      // Flashlight cone
      const dx = mouseX - px;
      const dy = mouseY - py;
      let len = Math.hypot(dx, dy);
      if (len < 0.001) len = 1;
      const dirX = dx / len;
      const dirY = dy / len;

      const coneLength = 260;
      const coneWidth  = Math.PI / 10; // narrow cone

      const angle = Math.atan2(dirY, dirX);
      const a1 = angle - coneWidth;
      const a2 = angle + coneWidth;

      const tip1x = px + Math.cos(a1) * coneLength;
      const tip1y = py + Math.sin(a1) * coneLength;
      const tip2x = px + Math.cos(a2) * coneLength;
      const tip2y = py + Math.sin(a2) * coneLength;

      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(tip1x, tip1y);
      ctx.lineTo(tip2x, tip2y);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    let last = performance.now();
    function loop(t) {
      const dt = Math.min((t - last) / 1000, 0.05);
      last = t;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
